package v2

import (
	"encoding/json"
	"errors"
	"github.com/dgrijalva/jwt-go"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"path/filepath"
	"strings"
	"time"
)

// GrantType represents the grant type used in the OAuth2 protocol.
type GrantType int

const (
	// GrantTypeInitial is the initial grant type.
	GrantTypeInitial GrantType = iota
	// GrantTypeRefresh is the refresh grant type.
	GrantTypeRefresh
)

// TokenRequest represents a request to generate an OAuth2 token.
type TokenRequest struct {
	// Assertion is the assertion used to generate the token.
	Assertion string `json:"assertion,omitempty"`
	// RefreshToken is the refresh token used to generate the token.
	RefreshToken string `json:"refresh_token,omitempty"`
	// GrantType is the grant type used to generate the token.
	GrantType string `json:"grant_type"`
	// ClientID is the client ID used to generate the token.
	ClientId string `json:"client_id"`
	// ClientSecret is the client secret used to generate the token.
	ClientSecret string `json:"client_secret"`
	// Scope is the scope used to generate the token.
	Scope string `json:"scope,omitempty"`
}

// String() returns a string representation of the grant type.
func (g GrantType) String() string {
	switch g {
	case GrantTypeInitial:
		return "urn:ietf:params:oauth:grant-type:jwt-bearer"
	case GrantTypeRefresh:
		return "refresh_token"
	default:
		return "unknown"
	}
}

// TokenResponse represents a response to generate an OAuth2 token.
type TokenResponse struct {
	// AccessToken is the access token generated by the server.
	AccessToken string `json:"access_token"`
	// RefreshToken is the refresh token generated by the server.
	RefreshToken string `json:"refresh_token,omitempty"`
	// TokenType is the type of token generated by the server.
	TokenType string `json:"token_type"`
	// ExpiresIn is the number of seconds until the token expires.
	ExpiresIn string `json:"expires_in"`
	// Scope is the scope of the token.
	Scope string `json:"scope"`
}

// GenerateAuthToken : clientId, serviceAccount から keyFilePath の秘密鍵を用いて署名された JWT を生成する。
func GenerateAuthToken(clientId, serviceAccount string, keyFilePath string) (string, error) {
	absKeyPath, err := filepath.Abs(filepath.Clean(keyFilePath))
	if err != nil {
		return "", err
	}

	// RSA秘密鍵抽出
	signBytes, err := ioutil.ReadFile(absKeyPath)
	if err != nil {
		return "", err
	}
	signKey, err := jwt.ParseRSAPrivateKeyFromPEM(signBytes)
	if err != nil {
		return "", err
	}

	// 発行日を現在日時、有効期限はその30分後に設定
	issuedAt := time.Now().Unix()
	expiresAt := time.Now().Add(30 * time.Minute).Unix()

	token := jwt.New(jwt.SigningMethodRS256)
	claims := token.Claims.(jwt.MapClaims)
	claims["iss"] = clientId
	claims["sub"] = serviceAccount
	claims["iat"] = issuedAt
	claims["exp"] = expiresAt

	tokenString, err := token.SignedString(signKey)
	if err != nil {
		return "", err
	}

	return tokenString, nil
}

// ToForm : TokenRequest を application/x-www-form-urlencoded で使う url.Values に変換する。
func (t *TokenRequest) ToForm() url.Values {
	form := url.Values{}
	// assertion
	if t.Assertion != "" {
		form.Add("assertion", t.Assertion)
	}
	// refresh_token
	if t.RefreshToken != "" {
		form.Add("refresh_token", t.RefreshToken)
	}
	// grant_type
	form.Add("grant_type", t.GrantType)
	// client_id
	form.Add("client_id", t.ClientId)
	// client_secret
	form.Add("client_secret", t.ClientSecret)
	// scope
	if t.Scope != "" {
		form.Add("scope", t.Scope)
	}
	return form
}

// GetAccessToken : TokenRequest をもとに v2 token endpoint を呼び出してアクセストークンを取得する。
func (t *TokenRequest) GetAccessToken() (TokenResponse, error) {
	endpoint := "https://auth.worksmobile.com/oauth2/v2.0/token"
	body := strings.NewReader(t.ToForm().Encode())

	req, err := http.NewRequest(http.MethodPost, endpoint, body)
	if err != nil {
		return TokenResponse{}, err
	}
	// content-type
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")

	client := &http.Client{}
	client.Timeout = time.Second * 30
	resp, err := client.Do(req)
	if err != nil {
		return TokenResponse{}, err
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			log.Println(err)
		}
	}(resp.Body)

	respBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return TokenResponse{}, err
	}

	var tokenResponse TokenResponse
	err = json.Unmarshal(respBody, &tokenResponse)
	if err != nil {
		return TokenResponse{}, err
	}
	if len(tokenResponse.AccessToken) == 0 {
		return TokenResponse{}, errors.New("access token could not issue, description = " + string(respBody))
	}

	return tokenResponse, nil
}
